{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/GameItem.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\npragma solidity ^0.8.7;\r\n\r\ncontract GameItem {\r\n\r\n    // store address of all the owners of particular item as in game one item can be owned by multiple owners\r\n    address[] public owners;\r\n\r\n    // attributes related to item\r\n    string public name;\r\n    string public typeOf;\r\n    uint256 public level;\r\n    string public version;\r\n\r\n    // initializing item \r\n    constructor(string memory _name, string memory _typeOf, uint256 _level, string memory _version) {\r\n        name = _name;\r\n        typeOf= _typeOf;\r\n        level = _level;\r\n        version = _version;\r\n    }\r\n\r\n    function getName() public view returns(string memory){\r\n        return name;\r\n    }\r\n\r\n    function getTypeOf() public view returns(string memory){\r\n        return typeOf;\r\n    }\r\n\r\n    function getLevel() public view returns(uint256){\r\n        return level;\r\n    }\r\n\r\n    function getVersion() public view returns(string memory){\r\n        return version;\r\n    }\r\n    // adding owner if item is sold\r\n    function addOwner(address buyer) public {\r\n        owners.push(buyer);\r\n    }\r\n\r\n    // trading item with another item\r\n\r\n    function tradeOwner(address buyer, address seller) public {\r\n        for(uint i = 0; i < owners.length; i++) {\r\n            if(owners[i] == seller) {\r\n                owners[i] = buyer;\r\n            }\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/GameStore.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\npragma solidity ^0.8.7;\r\nimport \"./Wallet.sol\";\r\nimport \"./GameItem.sol\";\r\n\r\nerror GameStore_NotValid();\r\nerror GameStore_NotOwner();\r\n\r\ncontract GameStore {\r\n\r\n    // this contains game original items\r\n    address[] public storeOriginalItems;\r\n\r\n    // this contains account details mapped to particular username\r\n    mapping (string => address) public Wallets;\r\n\r\n    // this contains listed game original items mapped to token price\r\n    mapping (address => uint256) public listedStoreItemsToToken;\r\n\r\n    // this contains listed custom made items mapped to token price\r\n    mapping (address => uint256) public listedUserMintedItemsToToken;\r\n\r\n    // this contains listed custom made items mapped to particular tradable item\r\n    mapping (address => address) public listedUserTradeItemsToItems;\r\n\r\n    // owner of the gameStore\r\n    address public immutable owner;\r\n\r\n    // initializing the owner of this contract\r\n    constructor() {\r\n        owner = msg.sender;\r\n    } \r\n\r\n    // this creates a new wallet and assign it to whoever created the wallet and map it to name\r\n    function createWallet(string memory name) public {\r\n        // this means wallet already exists\r\n        require(Wallets[name] == address(0), \"Wallet exist!!\");\r\n        Wallets[name] = address(new Wallet(msg.sender));\r\n    }\r\n\r\n    // this gets the wallet already create based on name\r\n    function getWallet(string memory name) public view returns(address){\r\n        require(Wallets[name] != address(0), \"Wallet does not exist!!\"); // if wallet not exists revert\r\n        Wallet wallet = Wallet(Wallets[name]);\r\n        require(wallet.getOwner() == msg.sender, \"Wallet is not owned by you!!!\"); // if wallet is not accessed by wallet owner revert\r\n        return Wallets[name];\r\n    }\r\n\r\n    // this creates game original items and push it to storeOriginalItems and set token price for item to be listed\r\n    function createItem(string memory _name, string memory _typeOf, uint256 _level, uint256 token)  public onlyOwner {\r\n        address createdItem = address(new GameItem(_name, _typeOf, _level, \"classic\"));\r\n        storeOriginalItems.push(createdItem);\r\n        listedStoreItemsToToken[createdItem] = token * 1e8;\r\n    }\r\n\r\n    // this is for buying store original item \r\n    function buyItem(string memory name, address gameItem) public {\r\n        // require both the wallet and item to exists\r\n        require(Wallets[name] != address(0) && listedStoreItemsToToken[gameItem] != 0, \"Wallet or game item does not exist!!\");\r\n        Wallet wallet = Wallet(Wallets[name]);\r\n        // require only wallet owner to make transactions and available Tokens in wallet should be more than listed amount\r\n        require(wallet.getOwner() == msg.sender &&  wallet.availableToken() >= listedStoreItemsToToken[gameItem], \"Wallet is not owned by you!!!\");\r\n        GameItem item = GameItem(gameItem);\r\n        item.addOwner(address(wallet)); // adding wallet address as owner\r\n        wallet.buyItem(address(item), listedStoreItemsToToken[gameItem]);\r\n    }\r\n\r\n    // this creates custome items for user using their wallet address\r\n    function createCustomItems(string memory walletName, string memory _name, string memory _typeOf, uint256 _level)  public onlyOwner {\r\n        // checks wallet exist or not\r\n        require(Wallets[walletName] != address(0), \"Wallet or game item does not exist!!\");\r\n        Wallet wallet = Wallet(Wallets[walletName]);\r\n        // checks who is accessing wallet\r\n        require(wallet.getOwner() == msg.sender, \"Wallet is not owned by you!!!\");\r\n        // creating a custom item\r\n        GameItem createdItem = new GameItem(_name, _typeOf, _level, \"custrom\");\r\n        // adding owner of newly created item\r\n        createdItem.addOwner(address(wallet));\r\n        // adding item to owner wallet\r\n        wallet.addCreateItem(address(createdItem));\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if(msg.sender != owner) {revert GameStore_NotOwner();}\r\n        _;\r\n    }\r\n\r\n}"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\npragma solidity ^0.8.7;\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\nlibrary PriceConverter {\r\n\r\n    function getPrice(AggregatorV3Interface priceFeed) internal view returns(uint256){\r\n        \r\n        (, int price,,,) = priceFeed.latestRoundData();\r\n       \r\n        return uint256(price);\r\n    }\r\n\r\n\r\n    function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed) internal view returns (uint256) {\r\n        uint256 ethPrice = getPrice(priceFeed);\r\n       \r\n        uint256 ethAmountUsd = ethPrice * ethAmount / 1e8;\r\n        return ethAmountUsd;\r\n    }\r\n}"
    },
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\npragma solidity ^0.8.7;\r\n\r\n// contains library function for ethereum to usd comparision\r\nimport \"./PriceConverter.sol\";\r\n\r\n// wallet contract\r\nimport \"./Wallet.sol\";\r\n\r\n// priceFeed contract for conversion\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\n\r\n// custom errors\r\nerror Token_NotOwner();\r\nerror Token_NoWalletAddress();\r\n\r\ncontract Token {\r\n    \r\n    using PriceConverter for uint256;\r\n    uint256 public constant usdPerToken = 20 *  1e18;  // setting usd per token price\r\n    AggregatorV3Interface public priceFeed; // priceFeed contract\r\n    address public immutable owner; // storing owner of token contract\r\n\r\n    constructor(address _api) {\r\n        owner = msg.sender;  // initializing owner to whoever deploying contract\r\n        priceFeed = AggregatorV3Interface(_api);\r\n    }\r\n\r\n    // removing direct ethereum sending functonalitites\r\n    receive() external payable{\r\n        revert Token_NoWalletAddress();\r\n    } \r\n\r\n    fallback() external payable{\r\n        revert Token_NoWalletAddress();\r\n    }\r\n\r\n\r\n    // it will send token to particular wallet address when user sends valid price\r\n    function sendToken(address walletAddress) public payable {\r\n        // getting usd sent to contract in the form of ethers\r\n        uint256 usdSent = msg.value.getConversionRate(priceFeed);\r\n        require(usdSent >= usdPerToken, \"Didn't Sent enough!\");\r\n        Wallet wallet = Wallet(walletAddress);\r\n        uint256 tokenNeedToSend = (usdSent * 1e8) / usdPerToken;\r\n        // sending calculated token to wallet\r\n        wallet.receiveToken(tokenNeedToSend);\r\n    }\r\n\r\n    // withdraw functionalities for owner to get all ethereum stored in contract\r\n    function withDraw() public onlyOwner{\r\n        (bool CallSuccess,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(CallSuccess, \"Call Failed\");\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if(msg.sender != owner) {revert Token_NotOwner();}\r\n        _;\r\n    }\r\n}"
    },
    "contracts/Wallet.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\npragma solidity ^0.8.7;\r\nimport \"./GameItem.sol\";\r\n\r\n\r\nerror Wallet_NotOwner();\r\n\r\ncontract Wallet {\r\n    \r\n    // default token = 10 per wallet account\r\n    uint256 private gameToken = 10 * 1e8;\r\n    uint256 private constant decimal = 1e8; // decimal point for token\r\n    address private owner; // owner of wallet\r\n    address[] private ownedItems;    // items owned by this account\r\n    \r\n    \r\n    // setting owner of wallet\r\n    constructor (address _owner) {\r\n        owner = _owner;\r\n    }\r\n\r\n    function getOwner() public view returns(address) {\r\n        return owner;\r\n    } \r\n\r\n    function availableToken() public view returns(uint256) {\r\n        return gameToken;\r\n    }\r\n\r\n    function getItem(uint256 index) public view returns(address) {\r\n        return ownedItems[index];\r\n    } \r\n\r\n    // incrementing tokens received by token contract\r\n    function receiveToken(uint256 tokens) external {\r\n        gameToken += tokens;\r\n    }\r\n\r\n    // buying item based on item address and decrementing its price\r\n    function buyItem(address item, uint256 sellingToken) external {\r\n        gameToken -= sellingToken;\r\n        ownedItems.push(item);\r\n    }\r\n\r\n    function addCreateItem(address item) external {\r\n        ownedItems.push(item);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}